// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"

	"cyber-risk-monitor/internal/graph/model"
	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Asset() AssetResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Scan() ScanResolver
}

type DirectiveRoot struct{}

type ComplexityRoot struct {
	Asset struct {
		CreatedAt     func(childComplexity int) int
		ID            func(childComplexity int) int
		LastScannedAt func(childComplexity int) int
		Name          func(childComplexity int) int
		Scans         func(childComplexity int) int
		Target        func(childComplexity int) int
		AssetType     func(childComplexity int) int
	}

	AuthPayload struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	Mutation struct {
		CreateAsset func(childComplexity int, input model.CreateAssetInput) int
		DeleteAsset func(childComplexity int, id string) int
		Login       func(childComplexity int, input model.LoginInput) int
		Register    func(childComplexity int, input model.RegisterInput) int
		StartScan   func(childComplexity int, assetID string) int
	}

	Query struct {
		Asset  func(childComplexity int, id string) int
		Assets func(childComplexity int) int
		Me     func(childComplexity int) int
		Scan   func(childComplexity int, id string) int
		Scans  func(childComplexity int, assetID *string) int
	}

	Scan struct {
		Asset        func(childComplexity int) int
		CompletedAt  func(childComplexity int) int
		ErrorMessage func(childComplexity int) int
		ID           func(childComplexity int) int
		Results      func(childComplexity int) int
		StartedAt    func(childComplexity int) int
		Status       func(childComplexity int) int
	}

	ScanResult struct {
		Banner   func(childComplexity int) int
		ID       func(childComplexity int) int
		Port     func(childComplexity int) int
		Protocol func(childComplexity int) int
		Service  func(childComplexity int) int
		State    func(childComplexity int) int
		Version  func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Role      func(childComplexity int) int
	}
}

type AssetResolver interface {
	Scans(ctx context.Context, obj *model.Asset) ([]*model.Scan, error)
}

type MutationResolver interface {
	Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error)
	Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error)
	CreateAsset(ctx context.Context, input model.CreateAssetInput) (*model.Asset, error)
	DeleteAsset(ctx context.Context, id string) (bool, error)
	StartScan(ctx context.Context, assetID string) (*model.Scan, error)
}

type QueryResolver interface {
	Me(ctx context.Context) (*model.User, error)
	Assets(ctx context.Context) ([]*model.Asset, error)
	Asset(ctx context.Context, id string) (*model.Asset, error)
	Scans(ctx context.Context, assetID *string) ([]*model.Scan, error)
	Scan(ctx context.Context, id string) (*model.Scan, error)
}

type ScanResolver interface {
	Asset(ctx context.Context, obj *model.Scan) (*model.Asset, error)
	Results(ctx context.Context, obj *model.Scan) ([]*model.ScanResult, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	switch typeName + "." + field {
	default:
		return 0, false
	}
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "GraphQL execution not fully implemented yet"))
}

var parsedSchema *ast.Schema

func init() {
	parsedSchema = &ast.Schema{
		Types:    map[string]*ast.Definition{},
		Query:    &ast.Definition{Name: "Query"},
		Mutation: &ast.Definition{Name: "Mutation"},
	}
}
